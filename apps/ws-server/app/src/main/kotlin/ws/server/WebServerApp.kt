/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package ws.server

import io.ktor.server.engine.*
import io.ktor.server.netty.*
import ws.server.api.ChatApi
import ws.server.domain.services.MessageWorkersService
import ws.server.domain.services.UserService
import ws.server.infrastructure.databases.mongodb.ChatContentDbImpl
import ws.server.infrastructure.databases.mongodb.MongoDb
import ws.server.infrastructure.databases.postgres.MetadataPostgresDb
import ws.server.infrastructure.databases.redis.ReddisDatabase
import ws.server.infrastructure.databases.redis.RedisStoreImpl
import java.io.FileInputStream
import java.util.*

class WebServerApp {
    val greeting: String
        get() {
            return "Hello I am web server!"
        }
}

fun main(args: Array<String>) {

    println(WebServerApp().greeting)

    val APP_CONFIG_FILE = System.getenv("APP_CONFIG_FILE")
    val isLocal = System.getenv("APP_CONFIG_FILE") == null

    val DEFAULT_CONFIG_FILE =
        if (isLocal) "apps/ws-server/app/src/main/resources/application.properties" else "/usr/src/app/app/src/main/resources/application.properties"

    val properties = Properties()
    // Load properties from the default file
    val propertyFile = FileInputStream(DEFAULT_CONFIG_FILE)
    properties.load(propertyFile)

    // Load environment-specific properties (e.g., application-docker.properties)
    val envProperties = Properties()
    println("APP_CONFIG_FILE: $APP_CONFIG_FILE")
    val envConfigFile = APP_CONFIG_FILE ?: DEFAULT_CONFIG_FILE
    println("Using config file $envConfigFile")

    FileInputStream(envConfigFile).use { input ->
        envProperties.load(input)
    }

    // Override default properties with environment-specific properties
    properties.putAll(envProperties)

    val migration = FlywayMigration(properties)
    migration.migrate()

    val metadataPostgresDb = MetadataPostgresDb(properties)
    val chatContentDbImpl = ChatContentDbImpl(MongoDb(properties))
    val userService = UserService(metadataPostgresDb)
    val redisStoreImpl = RedisStoreImpl(ReddisDatabase(properties))
    val messageWorkersService = MessageWorkersService(redisStoreImpl)
    val chatApi = ChatApi(metadataPostgresDb, chatContentDbImpl, userService, messageWorkersService, properties)

    //Initialize webserver
    val webserverPort = properties.getProperty("app.port", "8080").toInt()
    println("Initializing webserver on port $webserverPort...")
    embeddedServer(Netty, port = webserverPort) {
        chatApi.apply { main() }
    }.start(wait = true)
}


