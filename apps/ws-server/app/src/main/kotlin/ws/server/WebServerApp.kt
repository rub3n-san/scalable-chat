/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package ws.server

import io.ktor.server.engine.*
import io.ktor.server.netty.*
import ws.server.api.ChatApi
import ws.server.domain.services.MessageWorkersService
import ws.server.domain.services.UserService
import ws.server.infrastructure.databases.mongodb.ChatContentDbImpl
import ws.server.infrastructure.databases.mongodb.MongoDb
import ws.server.infrastructure.databases.postgres.MetadataPostgresDb
import ws.server.infrastructure.databases.redis.ReddisDatabase
import ws.server.infrastructure.databases.redis.RedisStoreImpl
import java.util.*

class WebServerApp {
    val greeting: String
        get() {
            return "Hello I am web server!"
        }
}

fun main(args: Array<String>) {
    println(WebServerApp().greeting)

    val DEFAULT_CONFIG_FILE = "application.properties"
    val properties = Properties()
    val propertiesStream = Thread.currentThread().contextClassLoader.getResourceAsStream(DEFAULT_CONFIG_FILE)
    properties.load(propertiesStream)

    val APP_CONFIG_FILE = System.getenv("APP_CONFIG_FILE")
    if (APP_CONFIG_FILE != null) {
        val specificEnvProperties = envSpecificProperties(APP_CONFIG_FILE)
        // Override default properties with environment-specific properties
        properties.putAll(specificEnvProperties)
    }

    val migration = FlywayMigration(properties)
    migration.migrate()

    val metadataPostgresDb = MetadataPostgresDb(properties)
    val chatContentDbImpl = ChatContentDbImpl(MongoDb(properties))
    val userService = UserService(metadataPostgresDb)
    val redisStoreImpl = RedisStoreImpl(ReddisDatabase(properties))
    val messageWorkersService = MessageWorkersService(redisStoreImpl)
    val chatApi = ChatApi(metadataPostgresDb, chatContentDbImpl, userService, messageWorkersService, properties)

    //Initialize webserver
    val webserverPort = properties.getProperty("app.port", "8080").toInt()
    println("Initializing webserver on port $webserverPort...")
    embeddedServer(Netty, port = webserverPort) {
        chatApi.apply { main() }
    }.start(wait = true)
}

private fun envSpecificProperties(APP_CONFIG_FILE: String): Properties {
    // Load environment-specific properties (e.g., application-docker.properties)
    val envProperties = Properties()
    println("Using environment-specific config file: $APP_CONFIG_FILE")
    val specificEnvFile = Thread.currentThread().contextClassLoader.getResourceAsStream(APP_CONFIG_FILE)
    envProperties.load(specificEnvFile)
    return envProperties
}


